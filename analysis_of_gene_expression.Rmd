---
title: "Analysis of gene expression"
author: "Job Maathuis"
date: "9-3-2022"
output: 
  pdf_document:
    toc: true
    toc_depth: 4
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
```
#  1. Exploratory Data Analysis

## 1.1 Loading in the data
The data consists of gene expression data which is available as raw count data in a single text file. For this reason the read.table() function can be used and no merging is needed. The column names were changed by using the 'patient_codes.csv'.

```{r}
setwd('C:/Users/jobma/Documents/School/Bio-informatica/Jaar_2/Kwartaal_3/practicum/')

data <- read.table('counts.txt', header = T, row.names = 1)
patient_codes <- read.csv('patient_codes.csv', header=F)
# shortening patient names by deleting the middle part
patient_codes[,2] <- gsub('-.*-', '-', patient_codes[,2])
colnames(data) <- patient_codes[,2][patient_codes[,1] == colnames(data)]
```


## 1.2 Data structure

The dataset has the following structure
```{r}
library(pander)
pander(head(data, 5))
print(dim(data))
print(str(data))
```
As can be seen above, the data consists out of 16,282 rows, corresponding to the genes, and 15 columns, which are the different samples. The structure of the samples is as follows:

*  3 patients with a mild disease severity (m29, m42, m43), each having 3 technical repeats
*  2 patients with a severe disease severity (s10, s11), each having 3 technical repeats

To distinguish between these groups, some variables are made.

```{r}
# variable for dataset name, which can be used later
name_dataset <- 'GSE181032'

# mild patients
m29 <- c(1, 6, 11)
m42 <- c(2, 7, 12)
m43 <- c(3, 8, 13)
m.all <- c(m29, m42, m43)

# severe patients
s10 <- c(4, 9, 14)
s11 <- c(5, 10, 15)
s.all <- c(s10, s11)
```

To get a quick look at the data the summary() function is used. With this function the minimum, first quartile, median, mean, third quartile and the maximum value of each column are obtained. 

```{r}
summary(data)
```
In the data above a large difference between the maximum values and the other values can be observed. This is probably due to the fact that the data contains a lot of zeros or low values. In a biological context this means that most of the genes that are analysed are 'off' and only a few genes are being expressed at time of the RNA-seq analysis. 

## 1.3 Data visualisation

### 1.3.1 Boxplot
Next a boxplot can be made to visualise the structure of the data.
```{r}
library(scales)
colors <- hue_pal(c=70)(5)
boxplot((data[,c(m29, m42, m43, s10, s11)] + 1),
        main = 'Boxplot of the count data for GSE181032',
        ylab = 'Log2(counts)', outline = F, las = 2, 
        col=rep(colors, each=3))
```
For every patient the repeats shows the same distrubution. This is also the case if the patients are compared. A somewhat larger deviation can be seen in s11-TR2 data. The large differences between the maximum values and the other values reflect the summary data in the previous chapter. 

### 1.3.2 Density plot
The distrubtion of the count data can also be visualised using a density plot.
```{r, message=FALSE}
library(affy)
plotDensity(log2(data + 0.1),  main = 'Density plot for GSE181032', 
       xlab = 'Log2(counts)', ylab = 'Density')
legend('topright', names(data), lty=c(1:ncol(data)),
       cex = 0.7, col=rep(colors, each=3))
abline(v=-1.5, lwd=1, col='red', lty=2)
```
All of the lines follow the same distrubution, where only m29-TR3 is a bit variated from the other data. This variation is not much, so this will probably not cause any big problems. The large peak at the left of the red stippled line is caused by all of the zero's in the dataset. 

### 1.3.3 Barplot
```{r}
barplot(colSums(data[,c(m29, m42, m43, s10, s11)]) / 1e3, las = 2,
        ylab = 'Sequencing depth (thousands of reads)',
        main = 'Read counts for GSE181032',
        col=rep(colors, each=3), ylim = c(0, 1000))
```
In the barplot a not much deviation can be seen between samples or within the samples. Only patient s11 has some larger deviation between the minimum and maximum sequencing depth. For this reason the dataset is being normalized. Normalization is achieved by using a variance stabilzing transformation (vst) form the DESeq2 library. When the data is normalzied sample distances can be calculated.

```{r, message=FALSE}
library("DESeq2")
# create a DESeq dataset
ddsMat <- DESeqDataSetFromMatrix(countData = data,
                                  colData = data.frame(samples = names(data)),
                                  design = ~ 1)
# normalization
rld.dds <- vst(ddsMat)
# obtain normalized data
rld <- assay(rld.dds)
# transposes and calculate distances
sampledists <- dist(t(rld))
```


### 1.3.4 Heatmap
Using the calculated sample distances a heatmap can be created.
```{r}
library(pheatmap)

# Convert the sample distances into a matrix for creating a heatmap
sampleDistMatrix <- as.matrix(sampledists)

# create annotation, which represents the design of the data
annotation <- data.frame(Patient = factor(rep(1:5, times = 3), 
                                          labels = c("m29", "m42", "m43", "s10", "s11")),
                         Condition = factor(rep(c(rep("mild", times = 3),
                                                rep("severe", times = 2)), times = 3),
                                            levels = c('mild', 'severe')),
                         Repeat = factor(rep(rep(1:3, times = 1), each = 5),
                                         labels = c("R1", "R2", "R3")))
                         
# Set the rownames of the annotation dataframe to the sample names (
rownames(annotation) <- names(data)

# Create heatmap
pheatmap(sampleDistMatrix, show_colnames = FALSE,
         annotation_col = annotation[,c(1,2)],
         clustering_distance_rows = sampledists,
         clustering_distance_cols = sampledists,
         main = "Euclidean Sample Distances")
```
In the heatmap a clustering can be seen. The mild and severe patients are divided. The mild patients are orange colored and the severe patients show a dark red color. This color difference, and therefor the overal expression, is not very large. Furthermore, each patient except for m43 can be seen as a cluster, because is shows a light ...

### 1.3.5 Multi-dimensional scaling

```{r}
library('PoiClaClu')
library('ggplot2')

dds <- assay(ddsMat)
# Calculate distances using Poisson distancesf
poisd <- PoissonDistance(t(dds))
# Extract the matrix with distances
samplePoisDistMatrix <- as.matrix(poisd$dd)
# Calculate the MDS and get the X- and Y-coordinates
mdsPoisData <- data.frame(cmdscale(samplePoisDistMatrix))

# Rename col names
names(mdsPoisData) <- c('x_coord', 'y_coord')

# Separate the annotation factor (as the variable name is used as label)
groups <- factor(rep(1:5, times=3), 
                 labels = c("m29", "m42", "m43", "s10", "s11"))
coldata <- names(data)

# Create the plot using ggplot
ggplot(mdsPoisData, aes(x_coord, y_coord, color = groups, label = coldata)) + 
  geom_text(size = 4) +
  ggtitle('Multi Dimensional Scaling') +
  labs(x = "Poisson Distance", y = "Poisson Distance") +
  xlim(-3000, 6500) +
  theme_bw()
```

All of the technical repeats from each patient are clustered together. Only s11-TR2 is somewhat seperated from the other repeats of the s11 patient, but this distance is still small.  For these reasons, the data does not have to be cleaned since there are no clear outliers visible. Furthermore, all of the mild patients are on the left, while the severe patience are a bit shifted to the right (all positive x-axis values)

# 2 Discovering differentialy expressed genes (DEGs)
## 2.1 Manual pre-processing

Later on we will use libraries in order to normalise the data and calculate the fold-changes of each gene. In order to get some insight into the data, this is done manually. First, the data is normalised to fragments per million mapped fragments 

```{r}
# Perform a naive FPM4 normalization
# Note: log transformation includes a pseudocount of 11
data.fpm <- log2( (data / (colSums(data) / 1e6)) + 1 )


data.fpm.filtered <- data.fpm[rowSums(data.fpm) >= 3,]
cat(nrow(data.fpm) - nrow(data.fpm.filtered), "genes have been filtered out")
```

```{r}
data.fpm$m.mean <- rowMeans(data.fpm[m.all])
data.fpm$s.mean <- rowMeans(data.fpm[s.all])
data.fpm$lfc <- data.fpm$m.mean - data.fpm$s.mean

hist(data.fpm$lfc, breaks=80)
abline(v=-1, col = 'red', lty=2)
abline(v=1, col = 'red', lty=2)
```

## 2.2 DESeq2
```{r, message=FALSE}
ddsMat <- DESeqDataSetFromMatrix(countData = data,
                                  colData = annotation,
                                  design = ~ Condition)
ddsMat <- DESeq(ddsMat, betaPrior = FALSE)
ddsMat <- collapseReplicates(ddsMat, groupby = annotation$Patient)
resultsNames(ddsMat)
```

```{r, message=FALSE}
res <- results(ddsMat, alpha = 0.05)
plotMA(res, ylim = c(-4.5, 4.5))
res <- lfcShrink(ddsMat, coef="Condition_severe_vs_mild", type="apeglm")
pander(summary(res))
plotMA(res, ylim = c(-4.5, 4.5))
```

## 2.3 EdgeR
```{r message=FALSE}
library(edgeR)
condition <- rep(c(rep(1, times=3), rep(2, times=2)), times = 3)
dge <- DGEList(counts = data, group = condition)
#dge <- collapseReplicates(dge, groupby = annotation$Patient)

design <- model.matrix(~ annotation$Condition)
keep <- filterByExpr(dge, design)
dge <- dge[keep, , keep.lib.sizes=FALSE]

dge <- calcNormFactors(dge)
dge <- estimateDisp(dge, design)
# plotMA(dge)

et <- exactTest(dge)
topTags(et, n = 20)

deGenes <- decideTestsDGE(et, p=0.05)
deGenes <- rownames(et)[as.logical(deGenes)]
plotSmear(et, de.tags=deGenes)
abline(h=c(-1, 1), col=2)
```

# 3 Data Analysis and Visualization

## 3.1 Volcano plot

### 3.1.1 DESeq2
```{r, message=FALSE}
library(EnhancedVolcano)

## Simple function for plotting a Volcano plot, returns a ggplot object
deseq.volcano <- function(res, datasetName) {
  return(EnhancedVolcano(res, x = 'log2FoldChange', y = 'padj',
                         lab=rownames(res),
                         title = paste(datasetName, "Severe vs Mild"),
                         subtitle = bquote(italic('FDR <= 0.05 and absolute FC >= 2')),
                         # Change text and icon sizes
                         labSize = 3, pointSize = 1.5, axisLabSize=10, titleLabSize=12,
                         subtitleLabSize=8, captionLabSize=10,
                         # Disable legend
                         legendPosition = "none",
                         # Set cutoffs
                         pCutoff = 0.05, FCcutoff = 2))
}

## Note: input data is the corrected DESeq2 output using the 'lfcShrink' function (see chapter 4)
deseq.volcano(res = res, datasetName = 'Corona')
```
### 3.1.2 EdgeR

```{r}
colnames(et) <- c("log2FoldChange", "logCPM", "padj")
res
deseq.volcano(res = et$table, datasetName = 'Corona')
```


## 3.2 Clustering

```{r}
res.ordered <- res[order(res$log2FoldChange, decreasing = T),]
top.degs <- res.ordered[1:20,]
print(top.degs)

expr.vals.degs <- subset(data, subset = rownames(data) %in% rownames(top.degs))
expr.vals.degs <- log2(expr.vals.degs + 1)

expr.vals.degs.ordered <- expr.vals.degs[
 match(row.names(top.degs), row.names(expr.vals.degs)),]

pheatmap(expr.vals.degs.ordered, annotation_col = annotation[,1:2],
        cluster_rows = T, cluster_cols = T)
```

